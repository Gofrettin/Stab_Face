using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Diagnostics;
using System.Collections;
using System.Threading;

using Stab_Face.Memory;
using Stab_Face.WoW_Process;
using Stab_Face;
using Stab_Face.Units.CombatRoutines;
using Stab_Face.Units.LogicStrategies;
using Stab_Face.WoW_Process.Buffs;
using Stab_Face.WoW_Process.Debuffs;
using Stab_Face.WoW_Process.Offsets;
using Stab_Face.Misc;
using System.Drawing;
using System.Windows.Forms;

namespace Stab_Face.Units
{
    public class Player : Unit
    {
        // Profile
        private Profile profile;

        // List of all Units near us
        private List<Unit> units;

        // Main Pulse to update variables and run Strats
        private Thread Pulse;

        // Combat Routine, specific to class
        private CombatRoutine cRoutine;
        
        // Logic Strategy
        private LogicStrategy lStrat;

        private List<Buff> buffs;
        private List<Debuff> debuffs;

        public Player(UInt32 objBase)
            : base(objBase)
        {
            // Find the current player object
            if (objBase == 0)
            {
                this.getObjects();
            }

            // TODO: get correct lStrat at runtime
            this.lStrat = new GeneralWaypointStrategy();

            // TODO: get correct cRoutine at runtime
            this.cRoutine = new RogueRoutine();

            // Units
            units = new List<Unit>();

            // Thread to run user logic
            Pulse = new Thread(new ThreadStart(doPulse));
        }

        /// <summary>
        /// Destructor.
        /// TODO: Implement Idisp and override correctly.
        /// </summary>
        ~Player()
        {
            Pulse.Abort();
        }

        /// <summary>
        /// Starts the user logic pulse.
        /// </summary>
        /// <param name="p">Profile to run.</param>
        public void start(Profile p)
        {
            this.profile = p;
            Pulse.Start();
        }

        /// <summary>
        /// Stops the user logic pulse.
        /// TODO: should probably do some other cleanup and
        /// actually make sure the Thread exited.
        /// </summary>
        public void stop()
        {
            Pulse.Abort();
        }

        /// <summary>
        /// Gets the currently set Profile for this Player.
        /// </summary>
        /// <returns></returns>
        public Profile getProfile()
        {
            return this.profile;
        }

        /// <summary>
        /// Returns the List generated by getObjects() .
        /// </summary>
        /// <returns>A List of nearby Units</returns>
        public List<Unit> getNearbyUnits()
        {
            return this.units;
        }

        /// <summary>
        /// Gets the Player's current Health.
        /// </summary>
        /// <returns>An unsigned integer value.</returns>
        public UInt32 getHP()
        {
            UInt32 hp = MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, this.objBase + PlayerOffsets.HP_OFFSET);
            return hp;
        }

        /// <summary>
        /// Gets the name of the current Player.
        /// </summary>
        /// <returns>Name of Player.</returns>
        public String getName() {
            string str = Stab_Face.Misc.Utils.byteArrToString(MemoryReader.ReadBytes(WoW_Instance.getProcess().Handle, 0xC27D88, 12)).Replace("\0", "").Trim();
            string name = "";
            foreach (char c in str) {
                if (Char.IsLetter(c))
                    name += c.ToString();
            }
            return name;
        }

        /// <summary>
        /// Gets the maximum amount of Health of the Player.
        /// </summary>
        /// <returns>An unsigned integer value.</returns>
        public UInt32 getMaxHP() {
            return MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.MAX_HP_OFFSET);
        }

        /// <summary>
        /// Gets the Player's power:
        /// Mana / Rage / Energy
        /// </summary>
        /// <returns>An unsigned integer value.</returns>
        public UInt32 getPower() {
            // Testing with a rogue, this will need to verify class before returning.
            return MemoryReader.ReadBytes(WoW_Instance.getProcess().Handle, this.objBase + PlayerOffsets.ENERGY, 1)[0];
            //return MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.POWER_OFFSET);
        }

        /// <summary>
        /// Rogue specific attribute.
        /// </summary>
        /// <returns>Number of combo points on current target.</returns>
        public UInt16 getComboPoints()
        {
            return MemoryReader.ReadBytes(WoW_Instance.getProcess().Handle, this.objBase + PlayerOffsets.COMBO_POINTS, 1)[0];
        }
        /// <summary>
        /// Gets a buff ID from the specified slot.
        /// </summary>
        /// <param name="slot">Buff slot</param>
        /// <returns>An unsigned integer value.</returns>
        public UInt32 getBuff(int slot) {
            return MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, (uint)((objBase + PlayerOffsets.BUFFS_OFFSET) + (slot * 0x04)));
        }

        /// <summary>
        /// Gets a debuff ID from the specified slot.
        /// </summary>
        /// <param name="slot">Debuff slot</param>
        /// <returns>An unsigned integer value.</returns>
        public UInt32 getDebuff(int slot) {
            return MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, (uint)((objBase + PlayerOffsets.DEBUFFS_OFFSET) + (slot * 0x04)));
        }

        /// <summary>
        /// Attempts to decipher if the Player is casting.
        /// Not sure if working correctly.
        /// </summary>
        /// <returns>True if casting, False otherwise.</returns>
        public Boolean isCasting() {
            if (MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.IS_CASTING_OFFSET) > 0 && MemoryReader.readUInt16(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.IS_CHANNELING_OFFSET) > 0)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Attempts to decipher if the Player is in combat.
        /// </summary>
        /// <returns>True if in combat, false otherwise.</returns>
        public Boolean isInCombat()
        {
            try
            {
                if (MemoryReader.ReadBytes(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.IN_COMBAT_OFFSET, 1)[0] > 0)
                    return true;
                else
                    return false;
            }
            catch (Exception ex)
            {

            }
            return false;
        }

        public Boolean isAlive()
        {
            if (this.getHP() > 1)
                return true;
            return false;
        }

        /// <summary>
        /// Checks all nearby units to see if they are targeting this player.
        /// </summary>
        /// <returns>A List of units targeting this player.</returns>
        public List<Unit> getUnitsTargetingPlayer()
        {
            List<Unit> lunits = new List<Unit>();
            foreach (Unit u in this.getNearbyUnits())
            {
                Waypoint uLoc = u.getLocation();
                if (((Mob)u).getTargetGUID() == this.getGUID())
                {
                    // Someone is targeting me!
                    lunits.Add(u);
                }
            }
            return lunits;
        }

        /// <summary>
        /// Attempts to decipher if the Player is moving.
        /// Not sure if working correctly.
        /// </summary>
        /// <returns>True if Moving, False otherwise.</returns>
        public Boolean isMoving()
        {
            if (MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, this.objBase + PlayerOffsets.IS_MOVING) > 0)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Moves to a specified Waypoint.
        /// Other movement function rely on this.
        /// Implements CTM struct for movement currently.
        /// TODO: Facade this when Settings are implmented
        /// </summary>
        /// <param name="wp"></param>
        private void moveToLoc(Waypoint wp)
        {
            if (!isInRange(wp, 1.0f))
            {

                int tries = 0;
                while (verifyWrite(wp.getX(), 0xC4D890) == false && tries < 3)
                {
                    MemoryWriter.WriteMem(WoW_Instance.getProcess(), 0xC4D890, BitConverter.GetBytes(wp.getX()));
                    tries++;
                    if (tries >= 3)
                        return;
                }
                tries = 0;
                Thread.Sleep(3);
                while (verifyWrite(wp.getY(), 0xC4D894) == false && tries < 3)
                {
                    MemoryWriter.WriteMem(WoW_Instance.getProcess(), 0xC4D894, BitConverter.GetBytes(wp.getY()));
                    tries++;
                    if (tries >= 3)
                        return;
                }
                tries = 0;
                Thread.Sleep(3);
                float z = wp.getZ();
                if (z == 0)
                {
                    // For glider imports
                    z = this.getLocation().getZ();
                }
                while (verifyWrite(wp.getZ(), 0xC4D898) == false && tries < 3)
                {
                    MemoryWriter.WriteMem(WoW_Instance.getProcess(), 0xC4D898, BitConverter.GetBytes(wp.getZ()));
                    tries++;
                    if (tries >= 3)
                        return;
                }
                tries = 0;
                Thread.Sleep(5);

                MemoryWriter.WriteMem(WoW_Instance.getProcess(), 0xC4D888, new byte[] { (byte)0x04 });
                //MemoryWriter.WriteMem(WoW_Instance.getProcess(), 0xC4D888, new byte[] { (byte)0x04 });

                //Thread.Sleep(200);
                //Debug.Print("Moving: " + isMoving());
                //while (isMoving())
                //    Thread.Sleep(15); //Enjoy the ride

                //Thread.Sleep(20);
            }
        }

        /// <summary>
        /// Moves a specified distance toward the given Waypoint.
        /// </summary>
        /// <param name="wp">Waypoint to move toward</param>
        /// <param name="d">Distance to move</param>
        private void moveDistance(Waypoint wp, float d)
        {
            // First, update player and target location and save them locally
            Waypoint player_loc = getLocation();

            // get the total distance
            float distance = player_loc.getDistance(wp);

            // Get the X vector
            float xVector = wp.getX() - player_loc.getX();

            // Get the Y vector
            float yVector = wp.getY() - player_loc.getY();

            // Find Theta
            float theta = (float)Math.Asin(.01f / distance);

            float newY = (float)Math.Sin(theta) * d;

            // Calc new X
            float newX = (float)Math.Cos(theta) * d;

            Waypoint to_move = new Waypoint(player_loc.getX() + newX, player_loc.getY() + newY, (player_loc.getZ() + wp.getZ()) / 2.0f);

            moveToLoc(to_move);
        }

        /// <summary>
        /// Moves within range of the current target.
        /// </summary>
        /// <param name="attackRange"></param>
        private void moveInRangeofTarget(float attackRange)
        {
            // First, update player and target location and save them locally
            Waypoint player_loc = getLocation();

            Waypoint target_loc = this.target.getLocation();

            if (!isInRange(target_loc, attackRange))
            {
                // get the total distance
                float distance = player_loc.getDistance(target_loc);

                // Get the X vector
                float xVector = target_loc.getX() - player_loc.getX();

                // Get the Y vector
                float yVector = target_loc.getY() - player_loc.getY();

                // Quadrant
                int quadrant = 0;
                if (xVector >= 0 && yVector >= 0)
                    quadrant = 1;
                else if (xVector < 0 && yVector >= 0)
                    quadrant = 2;
                else if (xVector < 0 && yVector < 0)
                    quadrant = 3;
                else
                    quadrant = 4;

                xVector = Math.Abs(xVector);
                yVector = Math.Abs(yVector);

                // Find Theta
                float theta = (float)Math.Acos(xVector / distance);
                //Debug.Print("Theta: " + theta);


                float toMove = distance - (attackRange - 2.0f);
                //Debug.Print("Distance to move: " + toMove);

                float newX;
                float newY;
                if (toMove < 0.0f)
                {
                    //faceTarget();
                }
                else
                {

                    // Calc new X
                    newX = (float)Math.Cos(theta) * toMove;

                    // Calc new Y
                    newY = (float)Math.Sin(theta) * toMove;

                    if (quadrant == 1)
                    {

                    }
                    else if (quadrant == 2)
                    {
                        newX = newX * -1;

                    }
                    else if (quadrant == 3)
                    {
                        newX = newX * -1;
                        newY = newY * -1;
                    }
                    else
                    {
                        newY = newY * -1;
                    }


                    Waypoint to_move = new Waypoint(player_loc.getX() + newX, player_loc.getY() + newY, (player_loc.getZ() + target_loc.getZ()) / 2.0f);

                    moveToLoc(to_move);
                }
            }

        }

        /// <summary>
        /// Checks if the given Waypoint object is within the given
        /// range of this Player.
        /// </summary>
        /// <param name="target_loc">Target location</param>
        /// <param name="range">Range maximum</param>
        /// <returns></returns>
        public Boolean isInRange(Waypoint target_loc, float range)
        {
            Waypoint player_loc = this.getLocation();

            float distanceToTarget = (float)Math.Sqrt(Math.Pow((target_loc.getY() - player_loc.getY()), 2.0) + Math.Pow((target_loc.getX() - player_loc.getX()), 2.0));
            //Debug.Print("Distance to target: " + distanceToTarget);

            if (distanceToTarget < range)
                return true;
            else
                return false;
        }

        /// <summary>
        /// Faces a given Location.
        /// Sometimes still acts a bit funny.
        /// TODO: Facade this when Settings are implmented
        /// </summary>
        /// <param name="wp">Waypoint to face</param>
        private void faceLocation(Waypoint wp)
        {
            float turnaccuracy = 0.2f;

            // First, update player and target location and save them locally
            Waypoint player_loc = this.getLocation();
            float PlayerFacing = this.getFacing();

            //get the angle to which we need to turn in order to face our target
            float f = (float)Math.Atan2(wp.getY() - player_loc.getY(), wp.getX() - player_loc.getX());
            //if the turning angle is negative
            //(sometimes happens, depending on negative coordinates and such)
            if (f < 0)
                //add the maximum possible angle (PI x 2) to normalize the negative angle
                f += (float)(Math.PI * 2);
            Debug.Print("Want to face: " + f);
            Debug.Print("Facing: " + PlayerFacing);

            if (PlayerFacing < (f + turnaccuracy) && PlayerFacing > (f - turnaccuracy))
            {
                // We are already facing withing the error margin
                Debug.Print("Already Facing");
            }
            else
            {
                double r, l;

                //if our current facing angle, in radians, is greater than
                //the angle which we desire to face
                if (PlayerFacing > f)
                {
                    Debug.WriteLine("Current Angle GREATER than where we want to be.");
                    //we'd have to turn past North if we're turning left
                    l = ((2 * Math.PI) - PlayerFacing) + f;
                    //we don't have to turn past North if we're turning right
                    r = PlayerFacing - f;
                }
                else
                {
                    Debug.WriteLine("Current Angle LESS than where we want to be.");
                    //we don't have to turn past North if we're turning left
                    l = f - PlayerFacing;
                    //we have to turn past North if we're turning right
                    r = PlayerFacing + ((2 * Math.PI) - f);
                }

                //let's please turn in the direction where we have to spend
                //the least amount of time turning
                //PostMessage.mouseHold((int)WoW_Instance.getProcess().MainWindowHandle, "right", 100, 100, false);
                Debug.WriteLine("L: " + l);
                Debug.WriteLine("R: " + r);
                    if (l < r) {
                        Debug.WriteLine("Turning Left.");
                        //turnkey = Post.ArrowKeys.Left;
                        // Banned for this method
                        //PostMessage.SendKeys((int)WoW_Instance.getProcess().MainWindowHandle, "{LEFT}");
                        PostMessage.ArrowKey((int)WoW_Instance.getProcess().MainWindowHandle, "left", true);
                        while (!(this.getFacing() < (f + turnaccuracy) && this.getFacing() > (f - turnaccuracy)))
                        {
                            //Thread.Sleep(10);
                            //PostMessage.ArrowKey((int)WoW_Instance.getProcess().MainWindowHandle, "left", 20);
                        }
                        PostMessage.ArrowKey((int)WoW_Instance.getProcess().MainWindowHandle, "left", false);
                        // try with mouse
                        //PostMessage.LinearSmoothMove(100f, 15, "left");
                    } else {
                        Debug.WriteLine("Turning Right.");
                        //turnkey = Post.ArrowKeys.Right;
                        // Banned for this method
                        //PostMessage.SendKeys((int)WoW_Instance.getProcess().MainWindowHandle, "{RIGHT}");
                        PostMessage.ArrowKey((int)WoW_Instance.getProcess().MainWindowHandle, "right", true);
                        while (!(this.getFacing() < (f + turnaccuracy) && this.getFacing() > (f - turnaccuracy)))
                        {
                            //Thread.Sleep(10);
                            //PostMessage.ArrowKey((int)WoW_Instance.getProcess().MainWindowHandle, "right", 20);
                        }
                        PostMessage.ArrowKey((int)WoW_Instance.getProcess().MainWindowHandle, "right", false);
                        //PostMessage.LinearSmoothMove(100f, 15, "right");
                    }
                    
                    
                //PostMessage.mouseHold((int)WoW_Instance.getProcess().MainWindowHandle, "right", 100, 100, true);
                //MemoryWriter.WriteMem(WoW_Instance.getProcess(), PlayerOffsets.FACING, BitConverter.GetBytes(f));
                //Thread.Sleep(10);
                //PostMessage.SendKeys((int)WoW_Instance.getProcess().MainWindowHandle, "{RIGHT}");
            }
        }

        /// <summary>
        /// Get the current facing direction of this Player.
        /// </summary>
        /// <returns>Direction</returns>
        private float getFacing()
        {
            return MemoryReader.readFloat(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.FACING);
        }


        // TODO: How did this even get here... Move to MemoryWriter.
        private Boolean verifyWrite(float verify, UInt32 address) {
            byte[] va = BitConverter.GetBytes(verify);
            byte[] ba = MemoryReader.ReadBytes(WoW_Instance.getProcess().Handle, address, 4);
            for (int i = 0; i < 4; i++)
            {
                if(va[i] != ba[i])
                    return false;
            }
            return true;
        }

        /// <summary>
        /// Attempts to target a Unit.
        /// Does not work very well currently.
        /// TODO: Facade this when Settings are implmented
        /// </summary>
        /// <param name="u"></param>
        private void targetUnit(Unit u)
        {
            // Tab targeting method
            /*if (target!= null && MemoryReader.readUInt64(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.CUR_TARGET_GUID_OFFSET) == u.getGUID())
                return; // Already targeting
            else
            {
                while (true)
                {
                    try
                    {
                        
                        faceLocation(u.getLocation());
                        PostMessage.SendKeys((int)WoW_Instance.getProcess().MainWindowHandle, "F");
                        Thread.Sleep(200);
                        if (MemoryReader.readUInt64(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.CUR_TARGET_GUID_OFFSET) == u.getGUID())
                            this.target = u;
                            return;
                    }
                    catch (Exception ex) { }
                }
            } */

            // Memory write method. Requires macro: '' bound to key 'T'.
            if (target != null && MemoryReader.readUInt64(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.CUR_TARGET_GUID_OFFSET) == u.getGUID())
                return; // Already targeting
            else
            {
                while (true)
                {
                    try
                    {

                        faceLocation(u.getLocation());
                        MemoryWriter.WriteMem(WoW_Instance.getProcess(), 0xB4E2E0, BitConverter.GetBytes(u.getGUID()));
                        Thread.Sleep(100);
                        PostMessage.SendKeys((int)WoW_Instance.getProcess().MainWindowHandle, "T");
                        Thread.Sleep(200);
                        if (MemoryReader.readUInt64(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.CUR_TARGET_GUID_OFFSET) == u.getGUID())
                            this.target = u;
                        return;
                    }
                    catch (Exception ex) { }
                }
            }
        }

        /// <summary>
        /// gets the Player's current target.
        /// </summary>
        /// <returns>Targeted Unit</returns>
        public Unit getTargetedUnit()
        {
            return this.target;
        }

        /// <summary>
        /// ONLY USE THIS FOR CREATING PROFILES
        /// </summary>
        /// <returns></returns>
        public Unit checkForTarget(Object o)
        {
            if (o.GetType().Equals(typeof(CreateProfile)))
            {
                UInt64 curTargetGUID = MemoryReader.readUInt64(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.CUR_TARGET_GUID_OFFSET);
                if (this.target != null)
                {
                    if (((Mob)this.target).getHP() > 0)
                    {
                        if (curTargetGUID == this.target.getGUID())
                        {
                            return this.target;
                        }
                    }
                }

                getObjects();
                foreach (Unit u in this.getNearbyUnits())
                {
                    if (u.getGUID() == curTargetGUID)
                    {
                        this.target = u;
                        return this.target;
                    }
                }
            }

            this.target = null;

            return this.target;
        }

        /// <summary>
        /// Cast an ability by keypress.
        /// will not trigger GCD.
        /// </summary>
        /// <param name="key"></param>
        private void castNoGCDByKey(string key)
        {
            Thread.Sleep(35);
            PostMessage.SendKeys((int)WoW_Instance.getProcess().MainWindowHandle, key);

            if (!this.isCasting())
            {
                int tries = 0; // try and make sure cast went off
                while (tries < 5)
                {
                    PostMessage.SendKeys((int)WoW_Instance.getProcess().MainWindowHandle, key);
                    Thread.Sleep(10);
                    tries++;
                }
            }
        }

        /// <summary>
        /// Attempts to loot the current target.
        /// Seems to be working fairly well but hijacks the mouse.
        /// TODO: Facade this when Settings are implmented
        /// </summary>
        /// <param name="u"></param>
        private void LootUnit(Unit u)
        {
            while(this.getLocation().getDistance(u.getLocation()) > 4.0f) {
                moveToLoc(u.getLocation());
                Thread.Sleep(200);
            }

            Boolean foundInteract = false;
            if (MemoryReader.readUInt64(WoW_Instance.getProcess().Handle, 0x00B4E2C8) == u.getGUID())
            {
                foundInteract = true;
                goto End;
            }

            Rectangle r = WoW_Instance.getWindowDimensions();

            for(int i = -50; i < 50; i+=25) {
                for(int j = -25; j < 75; j+=25) {
                    PostMessage.setCursor((i + (r.X + (r.Width / 2))), (j + (r.Y + (r.Height / 2))));
                    Thread.Sleep(200);
                    if (MemoryReader.readUInt64(WoW_Instance.getProcess().Handle, 0x00B4E2C8) == u.getGUID())
                    {
                        PostMessage.setCursor(((i+3) + (r.X + (r.Width / 2))), ((j+6) + (r.Y + (r.Height / 2))));
                        foundInteract = true;
                        goto End;
                    }
                }
            }
            End:

            if (foundInteract == true)
            {
                for (int i = 0; i < 3; i++)
                {
                    PostMessage.SendKeys((int)WoW_Instance.getProcess().MainWindowHandle, "{SHIFTD}");
                    Thread.Sleep(100);
                    PostMessage.SendKeys((int)WoW_Instance.getProcess().MainWindowHandle, "{SHIFTD}");
                    Thread.Sleep(100);
                    PostMessage.RightClick();
                    Thread.Sleep(200);
                }

                PostMessage.SendKeys((int)WoW_Instance.getProcess().MainWindowHandle, "{SHIFTU}");
            }
        }

        /// <summary>
        /// Player ToString override
        /// </summary>
        /// <returns></returns>
        public override String ToString()
        {
            String str = "";
            str += "Object Base Pointer: " + this.objBase + "\n";
            str += "MaxHP: " + this.getMaxHP() + "\n";
            str += "HP: " + this.getHP() + "\n";
            str += "Power: " + this.getPower() + "\n";
            str += "Name: " + this.getName() + "\n";
            str += "Faction: " + this.getFaction() + "\n";

            Waypoint wp = this.getLocation();
            str += "X: " + wp.getX() + "\n";
            str += "Y: " + wp.getY() + "\n";
            str += "Z: " + wp.getZ() + "\n";

            foreach (Unit u in units)
            {
                str += "\nObject Base Pointer: " + u.getObjBase() + "\n";
                str += "Mob GUID: " + ((Mob)u).getGUID() + "\n";
                str += "Mob HP: " + ((Mob)u).getHP() + "\n";
                str += "Mob Name: " + ((Mob)u).getName() + "\n";
                Waypoint mwp = ((Mob)u).getLocation();
                str += "Mob Location: " + "\n";
                str += "X: " + mwp.getX() + "\n";
                str += "Y: " + mwp.getY() + "\n";
                str += "Z: " + mwp.getZ() + "\n";
                str += "Faction: " + u.getFaction() + "\n";
            }

            return str;
        }

        /// <summary>
        /// Iterates over all the nearby game objects
        /// and adds them to the proper List.
        /// </summary>
        private void getObjects() {
            UInt32 objManagerPointer = MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, 0xB41414);
            //UInt64 curTargetGUID = 0;
            if(units != null)
                units.Clear();
            /*
            try
            {
                curTargetGUID = MemoryReader.readUInt64(WoW_Instance.getProcess().Handle, objBase + PlayerOffsets.CUR_TARGET_GUID_OFFSET);
            }
            catch (Exception ex)
            {
            }
            this.target = null;
             *  * */
            this.GUID = MemoryReader.readUInt64(WoW_Instance.getProcess().Handle, (objManagerPointer + 0xC0));
            

            UInt32 curObj = MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, (objManagerPointer + 0xAC));

            while (curObj != 0 && (curObj & 1) == 0) {
                UInt64 curGUID = 0;
                UInt32 objType = 0;
                try {
                    curGUID = MemoryReader.readUInt64(WoW_Instance.getProcess().Handle, (curObj + 0x30));

                    if (curGUID == this.GUID) {
                        //Debug.Print("Found Player Obj at " + curObj);
                        if (this.objBase == 0)
                            this.objBase = curObj;
                        //Debug.Print("Error catch " + MemoryReader.readFloat(WoW_Instance.getProcess().Handle, (curObj + 0x9C0)));
                    }
                    //else if (curGUID == curTargetGUID)
                    //{
                    //    this.target = new Unit(curObj);
                        // TODO: set null if dead
                    //}
                    else
                    {
                        objType = MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, (curObj + 0x14));
                        if (objType == 3) // NPC
                        {
                            units.Add(new Mob(curObj));

                            /* * Test to see if any mobs have me targeted
                            UInt64 targuid = ((Mob)units.Last()).getTargetGUID();
                            Debug.WriteLine(targetGUID.ToString("X16"));
                            if (targuid == this.getGUID())
                            {
                                // Someone is targeting me
                                Debug.WriteLine("Being targeted by: " + units.Last().getGUID().ToString("X16"));
                            }
                             * */
                        }
                        else
                        {//if(objType == 4) Player
                            //units.Add(new Mob(curObj));
                        }
                    }

                    //Debug.Print(string.Format("GUID: {0} - X: {1} Y: {2} Z: {3}", curGUID.ToString("X16"), x, y, z));
                    curObj = MemoryReader.readUInt32(WoW_Instance.getProcess().Handle, (curObj + 0x3C));
                }
                catch (Exception e) {
                    Debug.Print(e.Message);
                    break;
                }
            }
        }

        /// <summary>
        /// The Pulse should be responsible for updating the Buffs/Debuffs
        /// and calling CombatRoutine and LogicStrategy
        /// </summary>
        private void doPulse()
        {
            LogicRequest LR;
            CombatRequest CR;

            while (true)
            {
                try
                {
                    // Populate all nearby units before doing anything else
                    getObjects();


                    // Out of combat stuff
                    if(this.isAlive()) 
                    {
                        // TODO: eat / drink call to cRoutine
                        while (((float)this.getHP() / (float)this.getMaxHP()) < 0.9f && this.isInCombat() == false)
                        {
                            Thread.Sleep(200);
                        }
                    }


                    /* Pulse the Logic Strategy
                     * This should return a request containing
                     * either a movement location or a unit to target.
                    */

                    // If we have no target, move to a new location while looking for a target
                    if (this.target == null)
                    {
                        LR = lStrat.getRequest(this);

                        // Found a target, set it and move on to the combat strategy.
                        if (LR.getTarget() != null)
                        {
                            target = LR.getTarget();
                            Debug.WriteLine("Targeting: " + LR.getTarget().getGUID().ToString("X16"));
                            this.targetUnit(LR.getTarget());
                        }
                        // Found no target, try moving instead
                        else if (LR.getMove() != null)
                        {
                            moveToLoc(LR.getMove());
                        }
                    }

                    /* Pulse the CombatRoutine strategy
                     * This should loop until the current target dies.
                     * This logic may change in the future but it is simple
                     * enough for now.
                    */

                    // We have a target
                    if (this.target != null)
                    {
                        while (((Mob)this.target).getHP() > 0 && this.isAlive())
                        {
                            Thread.Sleep(100);
                            CR = cRoutine.getRequest(this);

                            if (CR.getMove() != null)
                            {
                                moveToLoc(CR.getMove());
                            }

                            if (CR.getAbility() != '.')
                            {
                                faceLocation(this.target.getLocation());
                                castNoGCDByKey(CR.getAbility().ToString());
                                Thread.Sleep(1000); // TODO: Add GCD Logic Just for testing
                            }
                        }

                        // LOOOOOOOTS
                        Thread.Sleep(50);
                        //if(!this.isInCombat())
                        if (this.getUnitsTargetingPlayer().Count < 1 && this.isAlive())
                            LootUnit(this.target);

                        // Remove our current target since it is dead.
                        this.target = null;
                    }

                    // wait before next pulse is sent
                    Thread.Sleep(100);
                }
                catch (Exception ex)
                {
                    // TODO
                    Debug.Print("Exception in main Pulse: " + ex.Message);
                    Debug.Print("From: " + ex.TargetSite);
                }
            }
        }
    }
}